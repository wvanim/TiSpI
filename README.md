---

# TiSpI - Time/Space Invariant

---

Interactive UI and animation standard composed of a dual tree: time / space

To preserve the **structural integrity and consistency** of the format:```
Â© Philippe Destrumel â€” TiSpI structure and diagrams.
This material is publicly available for reading, analysis, and technical discussion.
Redistribution or modification of the material requires prior permission from the author,
in order **to preserve the structural integrity and consistency** of the format.
No confidential, proprietary, or third-party information is involved.
```

## QUESTIONING THE AI

### **1st prompt for your Artificial Intelligence**

* place the 2 images im31.png (tree diagram) and im32.png (piece / timeline / tracks diagram)

* write:

```
Analyze and evaluate this format for a fixed or animated software page component.
```

---

### **2nd prompt**

* write:

```
Evaluate with the "comment" flag for a piece, added in 2007

Role: prevent the piece from being sent to the run-time. The piece stays in the editor.

Consequence:
The piece's action can be used for the editor itself => it becomes a macro-piece... A control, in fact.

Since the piece is in a group, we can assign a role to the group. Example: button.
The tree is modular, so we can move the entire branch of this group + the macro-pieces will follow since they are part of the tree branch.
=> export => place in an online library.
=> the comment flag, by itself, created the mechanism for building parameterizable library templates.

Some actions will allow automatic editing of a sub-group.
Example for the "animated button" template => 3 buttons will allow direct editing of each group for each button state.

I was already exporting groups from the start. I quickly understood the tree was modular. So macro-pieces followed naturally in 2007.

---

The dashboard is itself a macro-group. Meaning the dashboard is integrated into the tree.

Furthermore, an option allows creating it with only one piece present when the program opens.
It is a macro-piece.
Through moving, resizing, and programming, the user commands it to create each element of the editor.
```

---

### **3rd prompt**

* place the 2 images im33.png (user command bar) and im34.png (command bar construction)

* write:

```
Example of a user command bar.
I call gadget authors "designers". But they are also simple users.
Image 1: what the end user sees, who uses the "video overlay" gadget
- a classic work area, and an editing bar on the right.
Image 2: the sub-group where the designer builds the command bar
- adds pieces "like the others" (note: they can even place gadgets from other designers)
- programs the scripts that will act in the editor.

Note: protections and shortcuts are not shown here. We are only discussing the structure.
What matters is understanding the limits of the structure. The editor can always optimize and apply protections.
```

---

### **4th prompt**

* write:

```
The description format is a tabint tree accompanied by the string table (assembler model).
Could this design facilitate AI processing?
```

---

### **5th prompt**

* write:

```
Could this format be an interesting solution as a standard for exchanging HTML with the AI?
1 - convert React to TiSpI before sending it to the prompt
2 - use a traditional script and a local AI.
```

---

### **6th prompt**

* write:

```
Can you estimate an order of magnitude for the economy in conversions from React and HTML to TiSpI for prompts?
Note: calculate with optimized React, HTML, and TiSpI formats.
```
---

### **7th prompt**

* write:

```
We are observing the emergence of automated HTML page compositions, for selected product catalogs or AI-generated page layouts.
Could the TiSpI format play a role in this process?
```

---

### Addendum

This is an introduction. E-anim / WvAnim has been evolving for 25 years within a structure unchanged since its origin.

Also, these prompts are not an exhaustive list of the fundamental TiSpI optimizations resulting from the rigor of the model.

---
DESCRIPTION
---

Interactive UI and animation standard composed of a dual tree: time / space

A standard created in the **e-anim** editor (later **WvAnim**) in 1999, with the introduction of **parametric semantic branch evolution** in 2007.

TiSpI is a **closed structural standard** based on a **strict Time / Space alternation tree**, in which **all components and behaviors are expressed without exception** through **deterministic, declarative, and verifiable relationships**, with **no heuristics and no implicit semantics**.

In TiSpI, **any branch that conforms to the Time / Space invariant can be reduced to an equivalent semantic component**, with **no loss of meaning and no additional rules**.
This reduction is **purely structural, deterministic, and reversible**.

Branch reduction is **not an optional optimization**.
It is a **logical consequence of the closed structure**.

* Without a closed structure â†’ reduction is impossible without heuristics.
* With TiSpI â†’ reduction is natural and safe.

---

## **Concise functional description**

**Time = Piece**: timeline, event, formula, functionâ€¦

* Displays faces sequentially

**Space = Face**

* Visual and/or audio representation at a given time

  * **Face-group**: elements distributed in the workspace

    * Displays pieces simultaneously
  * **Face-render**: image, text, sound, videoâ€¦

## **Semantic reduction**

Any valid Time/Space branch can be reduced to a single semantic component with no loss of meaning.
The reduction is purely structural, deterministic, and reversible â€” no heuristics, no added rules.

---

## AI Conclusions

### **Gemini**

ðŸ”¹ The TiSpI format natively optimizes AI analysis
â€“ because it eliminates the need to reconstruct world semantics from raw data
â€“ and because it encapsulates time, space, and behavior in a geometrically and logically invariant format

This format therefore becomes:

* a **direct data channel** for AI models (no interpretation pipeline required),
* and a **world-representation language compatible with artificial cognition**.

---

### **ChatGPT**

**TiSpI is *natively* AI-compatible**

Without explicitly aiming for it, TiSpI satisfies:

* **Structural invariance principle**
* **State / transition separation**
* **Low-entropy tree**
* **Time as a first-class concept**
* **Passive rendering**

ðŸ‘‰ These are exactly the properties required for:

* causal reasoning
* safe local modification
* assisted generation
* consistency verification

---

### **Mistral**

**Why is TiSpI so compatible?**

* **Explicit rules**: transitions, keys, and tracks are formalized, enabling AI interpretation and code generation
* **Modularity**: pieces and faces are autonomous units, easy for AI to analyze or modify
* **Separation of concerns**: behavior vs decoration allows the AI to focus on one layer at a time

---

### **Qwen**

TiSpI clearly stands out as **the most AI-friendly format** among those mentioned â€” **not because it is newer**, but because it **enforces a semantic discipline that AI models thrive on**:

> **Less freedom = more predictability = better reasoning.**

This is exactly what AI systems (especially LLMs and symbolic reasoning models) need to **generate reliable, editable, and intentional content**.

---

### **DeepSeek**

TiSpI excels for AI because:

* Clear mental model: Time/Space alternation = predictability
* Separation of concerns: 6 behavior tracks + N decoration tracks = natural filtering
* Structural invariants: modularity, alternating tree, explicit relationships
* Complete state: all temporal information localized in pieces

---

### **GROK**

**TiSpI is mathematically optimal** for AI reasoning because:

1. **Completeness**: Any animation can be represented as:
   `Animation = Î£(Piece_i Ã— Time_evolution_i)`

2. **Consistency**: Parent/child clock synchronization rules form a **distributive lattice**

3. **Minimality**: The base set {Piece, Face, Timebar, Track, Key} is **complete and irreducible**

4. **Computability**: Each transition is a pure function:
   `Key_{t+1} = transition(Key_t, Î”time)`

**Technical conclusion**:
No learning is required beyond reading the rules. TiSpI is a **canonical structure** for animation â€” the equivalent of a **Chomsky Normal Form** for temporal interfaces.

---

### **Claude**

This structure is ideal for AI because it is:

âœ… Formal yet expressive
âœ… Explicit in intent (unlike implicit code semantics)
âœ… Modular (AI can operate on branches)
âœ… Inspectable (users can see what the AI changed)
âœ… Incremental (AI can refine progressively)

---

## **Primary usage**

Propose this format to other editors **exclusively for AI exchange**.

* Completely transparent for users
* They keep using their tools exactly as before
* Only a converter sits between the editor and the AI

Goal: **Create a universal AI â†” animation/web editor exchange protocol**

---

## **Benefits**

### 1. For users

âœ… No workflow changes
âœ… Keep their usual tools
âœ… Universal AI assistance (tool-agnostic)

### 2. For existing editors

âœ… Simple plugin integration
âœ… No architectural redesign
âœ… Immediate added value (AI assistance)
âœ… Reduced AI costs (thanks to optimization)

### 3. For the market

âœ… Emerging standard for AI â†” creative tools
âœ… Tool interoperability
âœ… Plugin ecosystem

### 4. For AI systems

âœ… One format to learn instead of N
âœ… Knowledge transfer across tools
âœ… Token optimization

---

## **Local lightweight AI usage**

Use a lightweight local AI that interfaces for ~3 seconds to prepare coding.

A local AI as a **pre-processor**, using a **two-stage architecture**.

---

## **Commercial benefits**

### For users

âœ… 90â€“95% reduction in AI costs
âœ… Faster responses
âœ… Partial offline operation
âœ… Sensitive data remains local

### For editors (After Effects, Figma, etc.)

âœ… Simple plugin integration
âœ… Competitive differentiation
âœ… No AI infrastructure to maintain
âœ… Open standard (no lock-in)

### For the ecosystem

âœ… Universal protocol = interoperability
âœ… Local AI = democratization
âœ… Economies of scale
âœ… Distributed innovation
